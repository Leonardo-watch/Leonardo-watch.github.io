<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL综合 | stella's Blog</title><meta name="keywords" content="stella"><meta name="author" content="stella"><meta name="copyright" content="stella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL综合前言读者知悉在阅读本文之前，请各位读者知悉：  本文讲解的MySQL以InnoDB为存储引擎，各种机制的讲述也默认以InnoDB为存储引擎下MySQL实现的机制为准。 本文使用的可视化工具是SQLyog  官方文档指路：https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F; 官方源码指路：https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;mysql-5">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL综合">
<meta property="og:url" content="https://leonardo-watch.github.io/2022/03/14/MySQL1.0/index.html">
<meta property="og:site_name" content="stella&#39;s Blog">
<meta property="og:description" content="MySQL综合前言读者知悉在阅读本文之前，请各位读者知悉：  本文讲解的MySQL以InnoDB为存储引擎，各种机制的讲述也默认以InnoDB为存储引擎下MySQL实现的机制为准。 本文使用的可视化工具是SQLyog  官方文档指路：https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F; 官方源码指路：https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;mysql-5">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2022-03-14T11:35:10.000Z">
<meta property="article:modified_time" content="2022-03-29T01:18:09.869Z">
<meta property="article:author" content="stella">
<meta property="article:tag" content="stella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/holo.png"><link rel="canonical" href="https://leonardo-watch.github.io/2022/03/14/MySQL1.0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL综合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-29 09:18:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%B0%8F%E7%BE%8A%E5%95%8A.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/public/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/public/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/public/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">stella's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL综合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-14T11:35:10.000Z" title="发表于 2022-03-14 19:35:10">2022-03-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-29T01:18:09.869Z" title="更新于 2022-03-29 09:18:09">2022-03-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL综合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL综合"><a href="#MySQL综合" class="headerlink" title="MySQL综合"></a>MySQL综合</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="读者知悉"><a href="#读者知悉" class="headerlink" title="读者知悉"></a>读者知悉</h3><p>在阅读本文之前，请各位读者知悉：</p>
<ol>
<li>本文讲解的MySQL以InnoDB为存储引擎，各种机制的讲述也默认以InnoDB为存储引擎下MySQL实现的机制为准。</li>
<li>本文使用的可视化工具是SQLyog</li>
</ol>
<p>官方文档指路：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a></p>
<p>官方源码指路：<a target="_blank" rel="noopener" href="https://github.com/facebook/mysql-5.6/tree/42a5444d52f264682c7805bf8117dd884095c476/storage/innobase">https://github.com/facebook/mysql-5.6/tree/42a5444d52f264682c7805bf8117dd884095c476/storage/innobase</a></p>
<hr>
<h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><p>​    常规操作并非本文重点内容，因此只会稍作讲述，具体更多的常规操作，请在互联网中寻找优质资源自行学习。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL <span class="operator">-</span>u root <span class="operator">-</span>p  <span class="comment">--登录</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看 </span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="comment">--创建</span></span><br><span class="line"><span class="keyword">create</span> database gundam;</span><br><span class="line"><span class="comment">--切换</span></span><br><span class="line">use gundam;</span><br><span class="line"><span class="comment">--删除</span></span><br><span class="line"><span class="keyword">drop</span> database gundam;</span><br><span class="line"><span class="comment">--修改编码</span></span><br><span class="line"><span class="keyword">alter</span> database gundam <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure>

<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建数据表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> undertale(</span><br><span class="line">	<span class="operator">-</span><span class="operator">&gt;</span>id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>room <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>kills <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>love <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">primary</span> key    <span class="comment">--定义为主键 </span></span><br><span class="line">auto_increment <span class="comment">--自增的属性 用于主键 数值加1</span></span><br><span class="line">engine 设置存储引擎 </span><br><span class="line">charset 设置编码</span><br><span class="line"></span><br><span class="line"><span class="comment">--显示数据表名</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看表的结构</span></span><br><span class="line"><span class="keyword">desc</span> undertale;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看指定表的创建语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> undertale;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除数据表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> undertale;</span><br><span class="line"></span><br><span class="line"><span class="comment">--truncate关键字</span></span><br><span class="line">与<span class="keyword">drop</span>的区别：<span class="keyword">truncate</span>只删除数据不删除表的结构(定义)，释放空间</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> undertale;</span><br><span class="line"></span><br><span class="line">删除表</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改表名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> love rename <span class="keyword">to</span> LOVE;</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改表 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> undertale</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">add</span> <span class="keyword">column</span> fun <span class="keyword">double</span>(<span class="number">5</span>, <span class="number">2</span>) <span class="keyword">first</span>;</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> undertale</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">add</span> <span class="keyword">column</span> fun <span class="keyword">double</span>(<span class="number">5</span>, <span class="number">2</span>) after name;</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改表 修改数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> undertale</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>modify id <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改表 修改列名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> undertale</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>change love LOVE <span class="type">int</span>;</span><br></pre></td></tr></table></figure>



<h3 id="sql操作-增删改查"><a href="#sql操作-增删改查" class="headerlink" title="sql操作(增删改查)"></a>sql操作(增删改查)</h3><h4 id="增加-插入"><a href="#增加-插入" class="headerlink" title="增加(插入)"></a>增加(插入)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account_info (account_id, account_email, account_nickname, acounttypr_id) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;123@qq.com&#x27;</span>, <span class="string">&#x27;观星先生&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> account_info <span class="keyword">WHERE</span> acount_id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account_info <span class="keyword">SET</span> account_nickname<span class="operator">=</span><span class="string">&#x27;Tieria&#x27;</span>, account_email<span class="operator">=</span><span class="string">&#x27;Watch@qq.com&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tfa.`fill_index`, tco.object_number <span class="keyword">AS</span> fill_number,tco.`object_number_fraction` <span class="keyword">AS</span> fill_fraction</span><br><span class="line">    <span class="keyword">FROM</span> `qtest_topic` qtt</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> `test_change_object` tco <span class="keyword">ON</span> qtt.`qtest_topicid` <span class="operator">=</span> tco.`qtest_topicid`</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> topic_fill_answer tfa <span class="keyword">ON</span> qtt.`topic_id` <span class="operator">=</span> tfa.topic_id</span><br><span class="line">    <span class="keyword">WHERE</span> qtt.`qtest_topicid` <span class="operator">=</span> <span class="number">577</span></span><br><span class="line">    <span class="keyword">AND</span> tco.`object_number` <span class="operator">=</span> tfa.`fill_number`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> fill_index</span><br></pre></td></tr></table></figure>

<h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><p><strong>…</strong></p>
<h3 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h3><p>​    一般来说，mysql是不允许有依赖关系的表数据删除的，如果真的要删，那就只能修改外键依赖然后删</p>
<ul>
<li>如果要修改外键的值，修改时十分麻烦：需要先将引用的外键删除<ul>
<li><strong>级联更新</strong>：【例】我将部门的id更新后，员工表中部门外键也一同更新</li>
</ul>
</li>
<li>如果要研发部门和其部下的员工，需要先删除部门下的所有员工，再将该部门删除<ul>
<li><strong>级联删除</strong>：【例】属于研发部门和其部下的员工全删除，只需要在外键表中删除外键数据即可，关联的表中的数据一并删除</li>
</ul>
</li>
</ul>
<p>当出现多张有依赖关系的表时设置级联删除 mysql可以帮你删掉所有关联的数据</p>
<p>删除逻辑是 当父表被删除时，子表（外键设置级联操作）数据也会被级联删除</p>
<p>但是子表删除的时候父表数据不会被删除 <del>而且当子表出现两个外键时，单独删除一个外键的父表 也会被InnoDB拒绝删除（有待考证）</del></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">具体命令是</span><br><span class="line">级联操作</span><br><span class="line"><span class="comment">-- 1. 添加级联操作</span></span><br><span class="line">	语法：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称</span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称) </span><br><span class="line">		<span class="keyword">ON</span> UPDATE CASCADE </span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br><span class="line"><span class="comment">-- 2. 分类：</span></span><br><span class="line">	<span class="number">1.</span> 级联更新：<span class="keyword">ON</span> UPDATE CASCADE</span><br><span class="line">	<span class="number">2.</span> 级联删除：<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCAD</span><br></pre></td></tr></table></figure>



<blockquote>
<p>具体操作请见实践部分</p>
</blockquote>
<h3 id="截断表"><a href="#截断表" class="headerlink" title="截断表"></a>截断表</h3><p>​    截断表可以用于删除表中的所有数据。截断表命令还会回收所有索引的分配页。截断表的执行速度与不带where子句的delete（删除）命令相同，甚至比它还要快。delete（删除）一次删除一行数据，并且将每一行被删除的数据都作为一个事务记录日志；而truncate （截断）表则回收整个数据页，只记录很少的日志项。delete（删除）和truncate（截断）都会回收被数据占用的空间，以及相关的索引。只有表的拥有者可以截断表。</p>
<p>​    另外，truncate表之后，如果有自动主键的话，会恢复成默认值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令是 <span class="keyword">truncate</span> <span class="keyword">table</span> users；</span><br></pre></td></tr></table></figure>



<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUM</span>() </span><br><span class="line">SUM一般与 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 连用 用来分组求和 不需要连很多表</span><br><span class="line"></span><br><span class="line">IFNULL(a, <span class="number">0</span>)</span><br><span class="line">如果a为<span class="keyword">null</span> 则用<span class="number">0</span>替换</span><br><span class="line"></span><br><span class="line">CONCAT(A, B)</span><br><span class="line">将A与B拼接</span><br><span class="line"></span><br><span class="line">GROUP_CONCAT(col) </span><br><span class="line">返回由属于一组的列值连接组合而成的结果</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​    本节讲述的是MySQL的基本操作，包括登录、对数据库的系列操作、对数据表的系列操作与对数据的系列操作（包括增删改查）。</p>
<p>​    其中最为重要的是<strong>数据查询</strong>，数据查询是数据库中最常用的操作。此外为了实现高性能，优秀的查询语句、合理的库表结构、合适的索引，三者缺一不可。因此作为刚开始接触MySQL的读者来说，有必要重点学习查询操作。</p>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>​    实际的SQL执行过程中，有时候我们生产过程需要保证某些SQL要么一起顺序执行成功，要么一起失败回滚，不能结束在中间某个环节。为实现这种需求，那么就有了事务的概念。事务是数据库中保证交易可靠的机制。</p>
<p>​    比如说，在人员管理系统中，删除一个人员，既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！在删除的过程中，我们会希望所有的删除操作全部都执行成功，不能有停在某一步的情况，否则，数据库中就会留下脏数据，影响到其他各种查询操作。</p>
<p>想要获知哪些存储引擎支持事务，请在SQLyog中键入<code>SHOW ENGINES;</code>得到以下结果：</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gYkdy.png" alt="gYkdy.png"></p>
<p>其中<code>Transactions</code> 字段标明存储引擎是否支持事务。</p>
<h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>​    一个事务中所有操作要不全部完成，要不全部不完成，不会结束在中间某个环节</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>​    事务结束后 对事物的所有操作就是永久的，除非有其他事务对数据进行修改，否则即使系统故障也不会丢失</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>​    一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>​    <strong>隔离性</strong>（isolation）指的是不同事务先后提交并执行后，最终呈现出来的效果是串行的，也就是说，对于事务来说，它在执行过程中，感知到的数据变化应该只有自己操作引起的，不存在其他事务引发的数据变化。<br>​    隔离性解决的是并发事务出现的问题 </p>
<blockquote>
<p>此特性与事务隔离级别连接紧密，具体相关请参见‘事务隔离级别’</p>
</blockquote>
<blockquote>
<p>原子性和一致性辨析:</p>
<p>​    原子性和一致性的的侧重点不同：<strong>原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。</strong>而<strong>一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见</strong></p>
</blockquote>
<p>既然说到了隔离性， 那就有必要深刻讲解一下数据库的事务隔离级别。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>​    Q：一个概念的出现势必是要用来解决某些问题或者描述某些东西，那么‘事务隔离级别’这个概念是用来干什么的？</p>
<p>​    A：首先我们需要知道，MySQL 是支持并发执行的。有的事务写、有的事务读，如果是读写冲突有可能发生脏写、脏读、不可重复读和幻读问题。而如果是写写冲突则就有可能会发生两类更新丢失问题。</p>
<p>​    并发是指同一时间支持多个用户对系统进行操作，不管是从效率还是收益上都是有绝对好处的</p>
<p>​    但是数据库中并发也会带来一些问题，多个用户同时对同一个数据进行操作，会破坏隔离性，让用户以为系统出了问题。</p>
<p>​    因此为解决并发带来的问题，实现不同程度的并发控制，SQL的标准制定者提出了4种隔离级别：<strong>read uncommitted（读未提交）</strong>，<strong>read committed（读已提交）</strong>，<strong>repeatable read（可重复读）</strong>，<strong>serializable（串行化）</strong>这几个隔离级别。</p>
<blockquote>
<p>PS：在MySQL中，如果使用InnoDB，默认隔离等级是可重复读（Repeatable read）</p>
</blockquote>
<p>​    在详细讲事务隔离级别之前需要先讲清楚数据库的并发场景和并发问题。</p>
<p>​    因为并发场景下两个人在同时对同一个数据进行操作的时候就会产生冲突，这种冲突就会导致用户发现最终读写出来的结果并不是预期结果 这样就出现了并发问题</p>
<h3 id="数据库并发场景"><a href="#数据库并发场景" class="headerlink" title="数据库并发场景"></a>数据库并发场景</h3><h4 id="读-读"><a href="#读-读" class="headerlink" title="读-读"></a>读-读</h4><p>​    不会冲突，不存在任何问题，不需要并发控制</p>
<h4 id="读-写"><a href="#读-写" class="headerlink" title="读-写"></a>读-写</h4><p>​    A线程读，B线程更新    B的更新在很多情况下都会给A的查询造成很大困扰 使得很多时候A没法得到自己预想的结果</p>
<p>​    有线程安全问题, 可能会遇上并发问题：脏读、不可重复读、幻读</p>
<h4 id="写-写"><a href="#写-写" class="headerlink" title="写-写"></a>写-写</h4><p>​    两个线程同时对同一个数据进行更新</p>
<p>​    有线程安全问题，可能会遇到更新丢失问题 比如第一类更新丢失 第二类更新丢失</p>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><blockquote>
<p>注意：接下来讲述的并发问题的示例中，事务A和事务B请读者想象成两个用户在不同的终端上进行的操作。</p>
</blockquote>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>​    脏读就是读到了不应该存在的数据，像是下面这样：<br>​    事务A更新数据 事务B查。 事务A在Time-5时 事务A撤销了对id = 1 的修改 导致B在两次查询出现数据不一致的情况</p>
<p>​    这就意味着事务B可以看到事务A在执行过程中任意时刻的修改，那B在执行的过程中有可能会发现需要查询的数值在乱窜（不止一次）</p>
<p><strong>示例：</strong></p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">ROLLBACK;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>​    不可重复读意思是 “我事务B对数据只做查询操作，我连着查了几次。但是突然发现我几次查出来的值都不一样。不应该啊，我只查了数据，并没修改啊，怎么会前后查出来的数据有变化呢？”<br>​    实际上是因为我事务B在查的时候 事务A就已经暗中在对数据进行修改了</p>
<p><strong>示例：</strong></p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">COMMIT;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>​    事务A的两次读之间有其他事务写操作，比如事务B统计年龄 &gt; 30，当A两次读数据之间其他事务新添加了记录，所以事务A第二次读取到的数据突然多了一个，仿佛出现了幻觉一般，这就是一种幻读</p>
<p><strong>示例：</strong></p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id &gt; 99;<br />此时五条数据</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">INSERT INTO students (id, name) VALUES (123, ‘Bob’);</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">COMMIT;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id &gt; 99;<br />此时六条数据，居然多了一条！</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">UPDATE students SET name = ‘Alice’ WHERE id = 123;<br />尝试对新增的数据进行更新操作，居然能成功！</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id &gt; 99;<br />此时六条数据</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<blockquote>
<p>不可重复读和幻读区别:</p>
<h5 id="精炼解释："><a href="#精炼解释：" class="headerlink" title="精炼解释："></a>精炼解释：</h5><ul>
<li><strong>不可重复读</strong>的重点是<strong>修改</strong>:<pre><code>    同样的条件, 你读取过的数据, 再次读取出来发现值不一样了
</code></pre>
</li>
<li><strong>幻读</strong>的重点在于<strong>新增</strong>或者<strong>删除</strong>：<pre><code>同样的条件, 第1次和第2次读出来的记录数不一样
</code></pre>
</li>
</ul>
<p>当然, 从总的结果来看, 似乎两者都表现为两次读取的结果不一致.<br>但如果你从控制的角度来看, 两者的区别就比较大</p>
<p>对于前者, 只需要锁住满足条件的记录<br>对于后者, 要锁住满足条件及其相近的记录</p>
</blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.php.cn/MySQL-tutorials-474519.html#:~:text=1">不可重复读和幻读的区别是什么-MySQL教程-PHP中文网</a> </p>
<p>前三者是<strong>读写冲突</strong>造成的问题，刚开始看可能稍微有点看不懂<br>但是如果稍微揣摩一下“我在读书 但是你（幽灵）在旁边乱改动我看到的字的话”<br>这三种就是读写冲突必然会发生的情况  理解起来也就容易很多了</p>
<p>接下来这种是<strong>写写冲突</strong>造成的问题：</p>
<h4 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h4><p>​    指两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务更新的情况，丢失更新是数据没有保证一致性导致的。比如，事务A修改了一条记录，事务B在事务A提交的同时也进行了一次修改并且提交。当事务A查询的时候，会发现刚才修改的内容没有被修改，好像丢失了更新。</p>
<p>​    更新丢失有两类：<strong>回滚丢失（Lost update）</strong> 和 <strong>覆盖丢失（又称两次更新问题， Second lost update）</strong></p>
<h5 id="回滚丢失"><a href="#回滚丢失" class="headerlink" title="回滚丢失"></a>回滚丢失</h5><p>​    在事务A期间，事务B对数据进行了更新；在事务A撤销之后，覆盖了事务B已经提交的数据。</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>查询学生A住址<br />上海市</td>
<td></td>
</tr>
<tr>
<td></td>
<td>查询学生A住址：<br />上海市</td>
</tr>
<tr>
<td></td>
<td>修改学生A住址成  九江市</td>
</tr>
<tr>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>修改学生A住址成  北京市</td>
<td></td>
</tr>
<tr>
<td>回滚</td>
<td></td>
</tr>
<tr>
<td>（此时学生A住址仍是上海市，事务B修改结果失效) – 回滚丢失</td>
<td></td>
</tr>
</tbody></table>
<h5 id="覆盖丢失"><a href="#覆盖丢失" class="headerlink" title="覆盖丢失"></a>覆盖丢失</h5><p>​    在事务A期间，事务B对数据进行了更新；在事务A提交之后，覆盖了事务B已经提交的数据。<br>​    第二类丢失更新，实际上和不可重复读是同一种问题。</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>查询学生A住址<br />上海市</td>
<td></td>
</tr>
<tr>
<td></td>
<td>查询学生A住址：<br />上海市</td>
</tr>
<tr>
<td></td>
<td>修改学生A住址成  九江市</td>
</tr>
<tr>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>修改学生A住址成  北京市</td>
<td></td>
</tr>
<tr>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>（此时学生A住址是北京市，事务B修改结果失效）– 覆盖丢失</td>
<td></td>
</tr>
</tbody></table>
<h3 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h3><p>​    在’事务隔离级别’ 中简单介绍了四种隔离等级</p>
<p>​    在这一讲中，将重点讲述四种隔离等级的概念并指明这些概念将解决哪些并发问题（本文中，事务隔离级别、事务隔离等级是同义词）</p>
<p>​    为让读者有个大致概念，先行放出图如下：</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gYwL0.png" alt="gYwL0.png"></p>
<p>​    此外，以上四种事务隔离等级都可以防止更新丢失问题。</p>
<h4 id="读未提交（Read-uncommitted）"><a href="#读未提交（Read-uncommitted）" class="headerlink" title="读未提交（Read uncommitted）"></a>读未提交（Read uncommitted）</h4><p>​    此隔离等级下，事务可以看到其他事务“尚未提交”的修改<br>​    会出现脏读问题。</p>
<h4 id="读已提交（Read-committed）"><a href="#读已提交（Read-committed）" class="headerlink" title="读已提交（Read committed）"></a>读已提交（Read committed）</h4><p>​    此隔离等级下可以避免脏读。</p>
<p>​    此隔离级别要求事务A提交之后，A修改后的值才能被事务B读到，所以脏读是不可能会发生的，从根本上杜绝了。但read commited会发生不可重复读的情况。<br>​    有时候，即使读到的值是一样的，也不能证明没问题。比如有财务挪用了2亿去炒股，然后在月底把2亿还了回来，虽然最终的金额都是一致的，但由于你的对账周期长，就发现不了这种差异。</p>
<blockquote>
<p>此时有些读者可能会出现这样的疑问：脏读和不可重复读有什么区别？</p>
<p>此二者区别在于 脏读时，事务A可以看到事务B“尚未提交”的修改，事务B在操作过程中可以乱修改值，这样A的查询结果<strong>可能每次都不一样</strong>；而在 不可重复读时，事务A只能看到其他事务提交后的结果，事务B在操作中修改数据并提交，导致A在查询时会发现数据<strong>有一次变化</strong>。</p>
</blockquote>
<h4 id="可重复读（Repeatable-read）"><a href="#可重复读（Repeatable-read）" class="headerlink" title="可重复读（Repeatable read）"></a>可重复读（Repeatable read）</h4><p>​    此隔离等级是MySQL默认隔离级别。</p>
<p>​    可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。<br>​    可重复是对比不可重复而言的，上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这就会遇到幻读问题。</p>
<blockquote>
<p> PS: 数据库不同，其支持的事务隔离级别亦不相同：MySQL数据库支持上面四种事务隔离级别，默认为Repeatable read；Oracle 数据库支持Read committed和Serializable两种事务隔离级别，默认为Read committed。 </p>
</blockquote>
<h4 id="可串行化（Serializable）"><a href="#可串行化（Serializable）" class="headerlink" title="可串行化（Serializable）"></a>可串行化（Serializable）</h4><p>​    Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p>
<p>​    虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p>
<p>因为在介绍以上四种隔离等级的时候提到了他们分别可以解决不同的冲突问题，接下来咱们来具体讲解一下这些问题到底是怎么解决的。</p>
<h3 id="隔离等级实现原理"><a href="#隔离等级实现原理" class="headerlink" title="隔离等级实现原理"></a>隔离等级实现原理</h3><p>在理解实现原理之前，你需要先知道两个先导概念 — 锁和MVCC</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>InnoDB Locking 官方文档指路：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7.1 InnoDB Locking</a></p>
<p>​    首先锁和下面的MVCC都是实现用以协调多个进程间并发访问同一共享资源的一种机制。<br>​    锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。它是MySQL在服务器层和存储引擎层的的并发控制。</p>
<p>​    在MySQL中，锁被分成了两类：锁类型（lock_type）和锁模式（lock_mode）。锁类型描述的锁的粒度，也就是把锁具体加在什么地方，有行锁、表锁之分，而行锁还细分为记录锁、间隙锁、插入意向锁、Next-Key等更细的子类型；而锁模式描述的是到底加的是什么锁，是读锁还是写锁。锁模式通常和锁类型结合使用。</p>
<p>接下来分别介绍锁类型和锁模式。</p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><h4 id="粒度锁"><a href="#粒度锁" class="headerlink" title="粒度锁"></a>粒度锁</h4><p>粒度锁有三种：<strong>页面锁</strong>、<strong>表级锁</strong>、<strong>行级锁</strong><br>MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p>
<ul>
<li>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）</li>
<li>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁</li>
<li>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</li>
</ul>
<p>默认情况下，表锁和行锁都是自动获得的，不需要额外的命令。<br>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><blockquote>
<p>A record lock is a lock on an index record. Record locks always lock index records, even if a table is defined with no indexes. For such cases, InnoDB creates a hidden clustered index and uses this index for record locking.</p>
</blockquote>
<p>上文出自MySQL的官方文档，从这里我们可以看出行锁是作用在索引上的，哪怕你在建表的时候没有定义一个索引，InnoDB也会创建一个聚簇索引并将其作为锁作用的索引。</p>
<p>这里还是讲一下InnoDB中的聚簇索引。每一个InnoDB表都需要一个聚簇索引，有且只有一个。如果你为该表定义一个主键，那么MySQL将使用主键作为聚簇索引；如果你不定义一个主键，那么MySQL将会把第一个唯一索引（而且要求NOT NULL）作为聚簇索引；如果上诉两种情况都GG，那么MySQL将自动创建一个名字为<code>GEN_CLUST_INDEX</code>的隐藏聚簇索引。</p>
<p>因为是聚簇索引，所以B+树上的叶子节点都存储了数据行，那么如果现在是二级索引呢？InnoDB中的二级索引的叶节点存储的是主键值（或者说聚簇索引的值），所以通过二级索引查询数据时，还需要将对应的主键去聚簇索引中再次进行查询。</p>
<p>需要注意的是，行锁作用的条件是查询语句的条件字段上是有建立索引，否则InnoDB会加表锁而非行锁。</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gYvLB.png" alt="gYvLB.png"></p>
<ul>
<li><p>查询条件为非主键索引，会在索引记录上加锁后，在去主键索引上加锁</p>
<p>这一点很好理解 用户如果条件中选择的列是 二级索引的话 InnoDB会先在二级索引加锁，然后还会在主键索引上加锁</p>
</li>
<li><p>如果查询时字段没有索引，进行全表记录加锁</p>
</li>
</ul>
<blockquote>
<p>此部分的讲解涉及到索引部分知识，这里读者可以先存疑，待阅读到“索引”小节后再回头来理解。</p>
</blockquote>
<h6 id="单行数据加锁原理"><a href="#单行数据加锁原理" class="headerlink" title="单行数据加锁原理"></a>单行数据加锁原理</h6><p>接下来以两条SQL的执行为例，讲解一下InnoDB对于单行数据的加锁原理：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">49</span>;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>第一条SQL使用主键查询，只需要在 id = 49 这个主键索引上加上锁。第二条 SQL 使用二级索引来查询，那么首先在 name = Tom 这个索引上加写锁，然后由于使用 InnoDB 二级索引还需再次根据主键索引查询，所以还需要在 id = 49 这个主键索引上加锁。</p>
<p>也就是说使用主键索引需要加一把锁，使用二级索引需要在二级索引和主键索引上各加一把锁。</p>
<h6 id="多行数据加锁原理"><a href="#多行数据加锁原理" class="headerlink" title="多行数据加锁原理"></a>多行数据加锁原理</h6><p>根据索引对单行数据进行更新的加锁原理了解了，那如果更新操作涉及多个行呢，比如下面 SQL 的执行场景。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">49</span>;</span><br></pre></td></tr></table></figure>

<p>上述 SQL 的执行过程如下图所示。MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁，接着 MySQL Server 发起更新改行记录的 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有匹配的记录为止。</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gYZ64.png" alt="gYZ64.png"></p>
<h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>​    上面我们讲解行锁的时候，操作语句中的条件判断列都是有建立索引的，那么如果现在的判断列不存在索引呢？InnoDB既支持行锁，也支持表锁，当没有查询列没有索引时，InnoDB就不会去搞什么行锁了，毕竟行锁一定要有索引，所以它现在搞表锁，把整张表给锁住了。那么具体啥是表锁？还有其他什么情况下也会进行锁表呢？</p>
<p>​    表锁使用的是一次性锁技术，也就是说，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。</p>
<p>​    除了使用 unlock tables 显示释放锁之外，会话持有其他表锁时执行lock table 语句会释放会话之前持有的锁；会话持有其他表锁时执行 start transaction 或者 begin 开启事务时，也会释放之前持有的锁。</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gY6CT.png" alt="gY6CT.png"></p>
<p>​    表锁由<code>MySQL服务层</code>实现，行锁则是<code>存储引擎</code>实现，不同的引擎实现的不同。在 MySQL 的常用引擎中InnoDB实现了行锁，因此支持行锁和表锁；而 MyISAM 未实现行锁，因此只能使用 <code>MySQL服务层</code>提供的表锁。</p>
<h5 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h5><p>​    因为InnoDB不支持页锁，因此这里不做讲解。</p>
<h5 id="不同粒度锁的比较"><a href="#不同粒度锁的比较" class="headerlink" title="不同粒度锁的比较"></a>不同粒度锁的比较</h5><p><strong>表级锁</strong>：<strong>开销小</strong>，<strong>加锁快</strong>；<strong>不会出现死锁</strong>；<strong>锁定粒度大</strong>，<strong>发生锁冲突的概率最高</strong>，<strong>并发度最低</strong>。</p>
<ul>
<li>一般在执行DDL语句时会对整个表进行加锁，比如说 ALTER TABLE 等操作；</li>
<li>存储引擎总是通过一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。</li>
<li>如果对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话，那么将会锁整张表；</li>
<li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</li>
</ul>
<p><strong>行级锁</strong>：<strong>开销大</strong>，<strong>加锁慢</strong>；<strong>会出现死锁</strong>；<strong>锁定粒度最小</strong>，<strong>发生锁冲突的概率最低</strong>，<strong>并发度也最高</strong>。</p>
<ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。</li>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而MySQL服务器层没有实现。</li>
<li>行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>
</ul>
<p><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；<strong>会出现死锁</strong>；锁定粒度界于表锁和行锁之间，<strong>并发度一般</strong>。</p>
<h3 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h3><h4 id="InnoDB中的行锁"><a href="#InnoDB中的行锁" class="headerlink" title="InnoDB中的行锁"></a>InnoDB中的行锁</h4><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li>共享锁(读锁/S锁)：允许事务读取一行数据，兼容读锁但不兼容写锁   — 其他事务可以读取数据但不能修改</li>
<li>排他锁(写锁/X锁)：允许获取该排他锁的事务更新或删除一行数据，不兼容读锁和写锁，其它锁均需要等待释放后再获取</li>
</ul>
<blockquote>
<p>​    所以，当一个事务在更新一行数据时，其它事务就不能对这行数据进行操作，只有等当前事务提交并释放锁之后其它事务才能读取或修改，也就避免了数据库层面的更新丢失问题。基于此机制，即使是读未提交级别也能避免更新丢失问题。通过显式加锁（FOR UPDATE、LOCK IN SHARE MODE）也可以避免脏读问题。</p>
</blockquote>
<h4 id="InnoDB表锁——意向锁"><a href="#InnoDB表锁——意向锁" class="headerlink" title="InnoDB表锁——意向锁"></a>InnoDB表锁——意向锁</h4><p>​    由于表锁和行锁虽然锁定范围不同，但是会相互冲突。当你要加表锁时，势必要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL引入了意向锁，来检测表锁和行锁的冲突。</p>
<p>意向锁也是表级锁，分为读意向锁（IS锁）和写意向锁（IX锁）:</p>
<ul>
<li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先加该表的 IS 锁。</p>
</li>
<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先加该表的 IX 锁。</p>
<p>当事务要在记录上加上行锁时，要首先在表上加上意向锁。这样判断表中是否有记录正在加锁就很简单了，只要看下表上是否有意向锁就行了，从而就能提高效率。</p>
<p>意向锁之间是不会产生冲突的，它只会阻塞表级读锁或写锁。意向锁不与行级锁发生冲突。</p>
</li>
</ul>
<h4 id="锁模式的兼容情况"><a href="#锁模式的兼容情况" class="headerlink" title="锁模式的兼容情况"></a>锁模式的兼容情况</h4><p><img src="https://s1.328888.xyz/2022/03/13/gYK1F.png" alt="gYK1F.png"></p>
<p>（注意:上面的X与S是说表级的X锁和S锁，意向锁不和行级锁发生冲突。）</p>
<p>（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）</p>
<h3 id="InnoDB加锁方法"><a href="#InnoDB加锁方法" class="headerlink" title="InnoDB加锁方法"></a>InnoDB加锁方法</h3><h4 id="行锁-1"><a href="#行锁-1" class="headerlink" title="行锁"></a>行锁</h4><ol>
<li>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)；</li>
<li>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br> 事务可以通过以下语句显式给记录集加共享锁或排他锁：<ul>
<li><strong>共享锁（S）</strong>：SELECT * FROM table_name WHERE … <strong>LOCK IN SHARE MODE</strong>。<br>   其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>**排他锁（X)**：SELECT * FROM table_name WHERE … <strong>FOR UPDATE</strong>。<br>   其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>
</ul>
</li>
</ol>
<blockquote>
<p>第一点中具体的作用机制请参见  “各种隔离等级的执行机制”小节</p>
</blockquote>
<ul>
<li><p><strong>隐式锁定：</strong></p>
<p>InnoDB在事务执行过程中，使用<strong>两阶段锁协议</strong>，即**2PL(Two-phase locking)**：</p>
<p>InnoDB会根据隔离级别在需要的时候自动加锁；<br>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p>
</li>
</ul>
<blockquote>
<p>实际上，InnoDB在实际使用的是 S2PL(Strict-2PL)，2PL和S2PL有些区别。对此在意的读者可以在附录中的‘2PL和S2PL的区别’小结中阅读。</p>
<p>严格的两阶段锁协议：</p>
<p>当一个事务获取到了某一个数据库对象的锁之后，并不是当前事务不需要操作它了之后，这个锁就会马上释放掉，这个锁会一直被这个事务持有，直到这个事务被提交或回滚后，这个锁才会被释放掉。所以，在当前事务还没有结束的时候，任何其他事务尝试获取这个锁的时候，都会被阻塞。知道当前事务提交或回滚后，前提事务才可以获取到这把锁。</p>
</blockquote>
<ul>
<li><p><strong>显式锁定 ：</strong></p>
<p>在sql语句中添上<br><strong>select … lock in share mode</strong> //共享锁<br><strong>select … for update</strong> //排他锁 </p>
</li>
</ul>
<h5 id="select-…-for-update"><a href="#select-…-for-update" class="headerlink" title="select … for update"></a>select … for update</h5><p>在执行这个 select 查询语句的时候，会将对应的索引访问条目加上排他锁（X锁），也就是说这个语句对应的锁就相当于update带来的效果；</p>
<p>​    <strong>使用场景</strong>：为了让确保自己查找到的数据一定是最新数据，并且查找到后的数据值允许自己来修改，此时就需要用到select for update语句；</p>
<p>​    <strong>性能分析</strong>：select for update语句相当于一个update语句。在业务繁忙的情况下，如果事务没有及时地commit或者rollback可能会造成事务长时间的等待，从而影响数据库的并发使用效率。</p>
<h5 id="select-…-lock-in-share-mode"><a href="#select-…-lock-in-share-mode" class="headerlink" title="select … lock in share mode"></a>select … lock in share mode</h5><p>in share mode 子句的作用就是将查找的数据加上一个共享锁（S锁），这个就是表示其他的事务只能对这些数据进行简单的 select 操作，而不能进行 DML 操作。</p>
<p>​    <strong>使用场景</strong>：为了确保自己查询的数据不会被其他事务正在修改，也就是确保自己查询到的数据是最新的数据，并且不允许其他事务来修改数据。与select for update不同的是，本事务在查找完之后不一定能去更新数据，因为有可能其他事务也对同数据集使用了 in share mode 的方式加上了S锁；</p>
<p>​    <strong>性能分析</strong>：select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p>
<h4 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li><p>意向锁是 InnoDB 自动加的， 不需用户干预。</p>
</li>
<li><p>显式锁定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES account_info READ;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="InnoDB的锁争用情况"><a href="#InnoDB的锁争用情况" class="headerlink" title="InnoDB的锁争用情况"></a>InnoDB的锁争用情况</h4><p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MySQL<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;InnoDB_row_lock%&#x27;</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+ </span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+ </span></span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_current_waits <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_time <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_time_avg <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_time_max <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_waits <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+ </span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：</p>
<p>show status like ‘InnoDB_row_lock%’; 从系统启动到现在的数据</p>
<p>InnoDB_row_lock_current_waits：当前正在等待锁的数量；</p>
<p>InnoDB_row_lock_time ：锁定的总时间长度，单位ms；</p>
<p>InnoDB_row_lock_time_avg ：每次等待所花平均时间；</p>
<p>InnoDB_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间；</p>
<p>InnoDB_row_lock_waits ：从系统启动到现在总共等待的次数。</p>
</blockquote>
<h3 id="InnoDB行锁的类型"><a href="#InnoDB行锁的类型" class="headerlink" title="InnoDB行锁的类型"></a>InnoDB行锁的类型</h3><p>上面我们根据了锁的粒度将锁分为了行锁与表锁，接下来根据使用场景的不同，又可以将行锁进行进一步的划分：’Next-Key Lock’、’Gap Lock’、’Record Lock’以及’插入意向GAP锁’。</p>
<p>不同的锁锁定的位置是不同的，比如说记录锁只锁定对应的记录，而间隙锁锁住记录和记录之间的间隙，Next-key Lock则锁住所属记录之间的间隙。不同的锁类型锁定的范围大致如图所示：</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gYcvv.png" alt="gYcvv.png"></p>
<h4 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h4><p>​    记录锁是最简单的一种行锁形式，上面在讲解InnoDB行锁的时候实际上就是讲解的记录锁。这里补充下的点就是：行锁是加在索引上的，如果当你的查询语句不走索引的话，那么它就会升级到表锁，最终造成效率低下，所以在写SQL语句时需要特别注意。</p>
<h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><blockquote>
<p>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record。</p>
</blockquote>
<p>​    当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；而对于键值在条件范围内但并不存在（空闲块,即由于删除或更新导致的空行）的记录，就叫做间隙，InnoDB在此时也会对间隙加锁，这种记录锁+间隙锁的机制叫Next-Key Lock。额，扯的有点快。</p>
<p>​    从上面这句话可以表明间隙锁是所在两个存在的索引之间，是一个开区间，像最开始的那张索引图，15和18之间，是有（16，17）这个间隙存在的。</p>
<blockquote>
<p>Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from inserting to the gap. Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.</p>
</blockquote>
<p>​    上面这段话表明间隙锁是可以共存的，共享间隙锁与独占间隙锁之间是没有区别的，两者之间并不冲突。其存在的目的都是防止其他事务往间隙中插入新的纪录，故而一个事务所采取的间隙锁是不会去阻止另外一个事务在同一个间隙中加锁的。</p>
<p>当然也不是在什么时候都会去加间隙锁的：</p>
<blockquote>
<p>Gap locking can be disabled explicitly. This occurs if you change the transaction isolation level to READ COMMITTED. Under these circumstances, gap locking is disabled for searches and index scans and is used only for foreign-key constraint checking and duplicate-key checking.</p>
</blockquote>
<p>​    这段话表明，在 RU 和 RC 两种隔离级别下，即使你使用 select in share mode 或 select for update，也无法防止<strong>幻读</strong>（读后写的场景）。因为这两种隔离级别下只会有<strong>行锁</strong>，而不会有<strong>间隙锁</strong>。而如果是 RR 隔离级别的话，就会在间隙上加上间隙锁。</p>
<h4 id="临键锁（Next-key-Lock）"><a href="#临键锁（Next-key-Lock）" class="headerlink" title="临键锁（Next-key Lock）"></a>临键锁（Next-key Lock）</h4><blockquote>
<p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p>
</blockquote>
<p>​    临键锁是记录锁与与间隙锁的结合，所以临键锁与间隙锁是一个同时存在的概念，并且临键锁是个左开有闭的却比如(16, 18]。</p>
<p>关于临键锁与幻读，官方文档有这么一条说明：</p>
<blockquote>
<p>By default, InnoDB operates in REPEATABLE READ transaction isolation level. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows.</p>
</blockquote>
<p>​    就是说 MySQL 默认隔离级别是RR，在这种级别下，如果你使用 select in share mode 或者 select for update 语句，那么InnoDB会使用临键锁（记录锁 + 间隙锁），因而可以防止幻读；</p>
<p>​    不过实际上，RR级别下，普通读使用的是MVCC机制，即普通读是快照读，快照读不存在幻读问题。</p>
<h4 id="插入意向锁（Insert-Intention-Lock）"><a href="#插入意向锁（Insert-Intention-Lock）" class="headerlink" title="插入意向锁（Insert Intention Lock）"></a>插入意向锁（Insert Intention Lock）</h4><blockquote>
<p>An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</p>
</blockquote>
<p>官方文档已经解释得很清楚了，这里我做个翻译机：</p>
<p>​    插入意图锁是一种间隙锁，在行执行 INSERT 之前的插入操作设置。如果多个事务 INSERT 到同一个索引间隙之间，但没有在同一位置上插入，则不会产生任何的冲突。假设有值为4和7的索引记录，现在有两事务分别尝试插入值为 5 和 6 的记录，在获得插入行的排他锁之前，都使用插入意向锁锁住 4 和 7 之间的间隙，但两者之间并不会相互阻塞，因为这两行并不冲突。</p>
<p>​    插入意向锁只会和 间隙或者 Next-key 锁冲突，正如上面所说，间隙锁作用就是防止其他事务插入记录造成幻读，正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。</p>
<h4 id="不同类型锁之间的兼容"><a href="#不同类型锁之间的兼容" class="headerlink" title="不同类型锁之间的兼容"></a>不同类型锁之间的兼容</h4><p>不同类型的锁之间的兼容如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>RECORED</th>
<th>GAP</th>
<th>NEXT-KEY</th>
<th>II GAP（插入意向锁）</th>
</tr>
</thead>
<tbody><tr>
<td>RECORED</td>
<td></td>
<td>兼容</td>
<td></td>
<td>兼容</td>
</tr>
<tr>
<td>GAP</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>NEXT-KEY</td>
<td></td>
<td>兼容</td>
<td></td>
<td>兼容</td>
</tr>
<tr>
<td>II GAP</td>
<td>兼容</td>
<td></td>
<td></td>
<td>兼容</td>
</tr>
</tbody></table>
<p>（其中行表示已有的锁，列表示意图加上的锁）</p>
<p>其中，第一行表示已有的锁，第一列表示要加的锁。插入意向锁较为特殊，所以我们先对插入意向锁做个总结，如下：</p>
<ul>
<li>插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的；</li>
<li>插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key 锁，则会阻塞。</li>
</ul>
<p>其他类型的锁的规则较为简单：</p>
<ul>
<li>间隙锁不和其他锁（不包括插入意向锁）冲突；</li>
<li>记录锁和记录锁冲突，Next-key 锁和 Next-key 锁冲突，记录锁和 Next-key 锁冲突；</li>
</ul>
<p>上文提到的那些锁实际上是InnoDB支持的锁。而MySQL存储引擎并不是只有InnoDB，还有MyISAM等。而MyISAM是不支持行锁的，它使用的是 <strong>表独占写锁</strong>、<strong>表共享读锁</strong>。</p>
<p>下面简单讲一下MyISAM的锁，因为日常开发并不是使用的MyISAM，所以不会讲得很详细，而更多的是描述其与InnoDB的区别点。</p>
<h3 id="MyISAM-—-表级锁"><a href="#MyISAM-—-表级锁" class="headerlink" title="MyISAM — 表级锁"></a>MyISAM — 表级锁</h3><ul>
<li>表共享读锁（Table Read Lock）：不会阻塞其他线程对同一个表的读操作请求，但会阻塞其他线程的写操作请求；</li>
<li>表独占写锁（Table Write Lock）：一旦表被加上独占写锁，那么无论其他线程是读操作还是写操作，都会被阻塞；</li>
</ul>
<p>默认情况下，写锁比读锁具有更高的优先级；当一个锁释放后，那么它会优先相应写锁等待队列中的锁请求，然后再是读锁中等待的获取锁的请求。</p>
<blockquote>
<p>This ensures that updates to a table are not “starved” even when there is heavy SELECT activity for the table. However, if there are many updates for a table, SELECT statements wait until there are no more updates.</p>
</blockquote>
<p>​    这种设定也是MyISAM表不适合于有大量更新操作和查询操作的原因。大量更新操作可能会造成查询操作很难以获取读锁，从而过长的阻塞。同时一些需要长时间运行的查询操作，也会使得线程“饿死”，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短的时间内完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。）</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jojop/p/13982679.html">【MySQL】MySQL中的锁机制 - 周二鸭 - 博客园 (cnblogs.com)</a></p>
<p>讲完了具体的锁，我们就上升一个层级来玩玩高级东西</p>
<p>接下来需要讲述的两种锁不是具体的锁，而是一种锁的思想</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>乐观锁，乐观并发控制，Optimistic Concurrency Control，缩写“OCC”</p>
<p>悲观锁，悲观并发控制，Pessimistic Concurrency Control，缩写“PCC”</p>
<p>悲观锁需要使用数据库的锁机制来实现，乐观锁是通过程序的手段来实现</p>
<h4 id="乐观锁和悲观锁的澄清"><a href="#乐观锁和悲观锁的澄清" class="headerlink" title="乐观锁和悲观锁的澄清"></a>乐观锁和悲观锁的澄清</h4><ol>
<li>无论是乐观锁（OCC）还是悲观锁（PCC）都不是数据库中具体的锁，他俩只是锁的一种思想。如此我们有了设计的分类，我们就可以按照这种分类对数据库的锁进行划分。</li>
<li>数据库中的乐观锁更倾向于叫 “乐观并发控制”，悲观锁更倾向于叫“悲观并发控制”，还有一种区别于悲观并发控制和乐观并发控制的一种控制叫做 MVCC，“多版本并发控制” </li>
<li>乐观锁和悲观锁是一种思想，而共享锁、排他锁、行锁、表锁等是数据库的具体的锁的实现</li>
<li>乐观锁和悲观锁不仅仅存在于数据库中，任何存在线程存在并发的场景下几乎都有乐观锁和悲观锁的应用场景。比如在java中也有乐观锁和悲观锁的具体实现。只是不同领域的实现不尽相同，解决的问题也可能不一样</li>
</ol>
<p><strong>所以要是以后有人问你乐观锁和悲观锁是啥，你千万别说它是两种锁，他俩只是一种锁的设计思想，他俩在不同的技术中会有不同的实现方式</strong></p>
<h4 id="悲观锁（Pessimistic-Concurrency-Control）"><a href="#悲观锁（Pessimistic-Concurrency-Control）" class="headerlink" title="悲观锁（Pessimistic Concurrency Control）"></a>悲观锁（Pessimistic Concurrency Control）</h4><p>​    悲观锁—即PCC 是指在读取数据的时候总是认为别人会修改它，于是在取数据的时候会对当前数据加一个锁，在结束事务前（提交事务前），不允许其他事务对当前数据进行更改。这样就保证数据的排他性，保证同一时间，只有一个线程能访问到该数据。 通常，悲观锁是利用数据库本身的锁机制去实现的。</p>
<p>​    数据库中的行锁，表锁，读锁（共享锁），写锁（排他锁），以及 syncronized实现的锁均为悲观锁</p>
<p>​    悲观锁是可以解决读-写冲突和写-写冲突，通过给数据加锁的方式</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol>
<li>一个事务要是想访问某条数据，就需要向数据库申请该数据的锁</li>
<li>申请成功了就能操作数据，在操作的过程中其他事务无法访问操作该数据</li>
<li>要是失败了就代表同一时间下，有其他事务正在操作该数据，那就必须等到事务释放锁</li>
</ol>
<p><img src="https://s1.328888.xyz/2022/03/13/gY3CJ.png" alt="gY3CJ.png"></p>
<h5 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h5><p>​    悲观并发控制机制，是一种“先取锁，再操作”的保守策略，为数据操作提供安全保障。但是从效率考虑，处理加锁的机制会让数据库产生额外的开销，还有增加死锁的机会；另外要是是只读型事务的话不会产生冲突，也没必要加锁，加了悲观锁反而会增大系统负载；还有就是降低了并行性，要是一个事务锁住了一行数据，其他事务就只能等着该事务处理完才能进行处理</p>
<p><strong>优点：</strong><br>    适合在写多读少的场景下使用，虽然无法做到很好的并发性，但是在乐观锁无法实现更好的性能的情况下，可以很好地保证数据操作的安全性</p>
<p><strong>缺点：</strong><br>    不适合在读多写少的场景下使用，并发性不好，数据吞吐量低，而且增大系统开销</p>
<p>​    </p>
<h4 id="乐观锁（Optimistic-Concurrency-Control）"><a href="#乐观锁（Optimistic-Concurrency-Control）" class="headerlink" title="乐观锁（Optimistic Concurrency Control）"></a>乐观锁（Optimistic Concurrency Control）</h4><p>​    乐观锁 — 即OCC 是指在读取数据的时候总会天真的认为没有人会去修改它，在更改操作的时候再去检查冲突。如果冲突了就返回冲突信息并由用户决定下一步如何去做，比如说重试，直到成功为止。数据库的乐观锁并不是由锁机制实现的 而是由某种逻辑实现的</p>
<p>​    数据库的乐观并发控制是要解决数据库并发场景下的写写冲突，用不加锁的方式解决</p>
<h5 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h5><h6 id="1-CAS思想"><a href="#1-CAS思想" class="headerlink" title="1.CAS思想"></a>1.CAS思想</h6><p>​    CAS思想是java中的一个思想，数据库的乐观锁实现逻辑原理和CAS思想类似</p>
<p>​    CAS指令全称Computer and swap，是一个系统的指令集，整个CAS指令操作是原子性的，不可分割.具体来说的话就是：</p>
<p>​        CAS会有三个操作数：内存位置V、旧的预期值A、新的修改值B。</p>
<p>​        当CAS执行操作的时候，先会去内存地址V中比较A的值。要是一致那就用B的值更新内存地址V的值，要是不一致的话就不执行更新，但无论是否更新，都会返回V的旧值</p>
<p>放到代码中理解的话就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">2</span>;i++;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先线程1从内存中读到了V地址上的旧值，并存储起来（a = 2）</li>
<li>然后进行i++操作的时候，系统会比较内存地址V的值和旧预期值，即 v值 = ? 2</li>
<li>要是相等，B = i++ = 3，新值就会对内存地址V进行修改，所以内存地址V的值现在变成了3</li>
<li>要是不相等，这就代表已经有其他线程修改过V的值了，比如线程2在线程1之前就更新了i值，所以线程1更新V值就会失败。但线程不会挂起，而是返回失败状态，等待调用线程决定是否重试或者其他操作（重试—重新读取最新数据，再过更新）</li>
</ol>
<p>数据库的乐观锁实现也类似上面代码层面的实现</p>
<p>当然CAS还只是一种思想，在数据库中由具体的实现方式</p>
<h6 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h6><p><strong>方式一：使用数据版本（version）实现</strong></p>
<ol>
<li><p>数据版本就是在表中添加一个字段作为该数据的版本标识，每次对这个数据进行的写操作都会让version值加1</p>
</li>
<li><p>当我们修改数据的时候会 就用CAS思想读取到version值 然后与旧预期值对应，要是一致就进行修改，同时version+1；要是不一致这就意味着在之前就有事务对这个数据进行了修改，就返回冲突信息，让用户自己决定是否重试或者进行其他操作（一般都是重试—重新读取最新数据，然后在执行更新）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set num = num + 1 , version = version + 1 where version = #&#123;version&#125; and id = #&#123;id&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>方式二：使用时间戳（timestamp）实现</strong></p>
<p>使用时间戳的原理基本和version一样 </p>
<ol>
<li><p>在表中添加一个时间戳，在更新提交的时候检查数据的时间戳和自己更新前取得的驱动是否一致，如果一致就代表之前没有事务对这个数据进行修改，于是就可以提交更新，同时更新时间戳致当前时间；不然就代表之前有其他事务在之前就对这个数据进行了修改，就返回冲突信息，等待用户进一步操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set num = num + 1 ,update_time = unix_timestamp(now()) where id = #&#123;id&#125; and update_time = #&#123;updateTime&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    实现CAS要保证CAS多个操作的原子性，即拿到数据库数据的版本，那数据库的数据版本和预期版本比较，以及更新数据这几个操作是必须是连贯执行的，具有符合操作的原子性；要是是sql的话就需要多个sql操作处于同一个事务中</p>
<h5 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h5><p><strong>优点：</strong></p>
<ol>
<li>在读多写少的情况下，可以避免数据库加锁的开销，提高dao层的响应速度</li>
<li>很多时候，orm（对象关系映射）工具都带有乐观锁的实现，很多时候不需要开发者自己实现</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>在写多读少的情况，在写操作竞争激烈的情况下，会导致CAS指令重试很多次，冲突频率过高，会极大增加开销</li>
</ol>
<h5 id="乐观锁和悲观锁的抉择"><a href="#乐观锁和悲观锁的抉择" class="headerlink" title="乐观锁和悲观锁的抉择"></a>乐观锁和悲观锁的抉择</h5><ol>
<li>响应速度： 如果Dao层需要很高的并发量，尤其是读多写少的场景下的话就用乐观锁，提高响应速度，降低数据库开销</li>
<li>冲突频率： 要是冲突频率很高，那建议用被悲观锁，保证成功率；因为要是是乐观锁的话， 冲突频率过高会导致事务会需要经常重试，开销太大了</li>
<li>重试代价： 要是重试代价高，比如说重试过程的代码执行很耗时，那不如直接上悲观锁会来得爽快</li>
</ol>
<p>所以：<br>    要是CAS竞争不高的话，就使用乐观锁，降低数据库开销，还提高数据库并发响应时间<br>    要是是写多读少的场景下，CAS竞争高，且重试代成本高，就直接上悲观锁</p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengyangcai/p/14431983.html">理解MySQL的乐观锁，悲观锁与MVCC</a></p>
<p><a target="_blank" rel="noopener" href="https://www.php.cn/mysql-tutorials-460111.html">全网最全的一篇数据库MVCC详解</a></p>
<p>—————————————————————————————-施工中————————————————————————————–</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>—————————————————————————————-施工中————————————————————————————–</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li>InnoDB一共支持四种锁，他们分别是 共享锁、排他锁、意向共享锁、意向排他锁。                                                                                其中 共享锁和排他锁是行锁，是InnoDB最常用的锁。                                                                                                                                    而意向共享锁和意向排他锁是表锁，作用是为防止用户在手动加表锁时造成大量的数据遍历，影响性能。</li>
<li>InnoDB有两种手动加锁方式：select … for update 和 select … lock in share mode ,他们分别加的是 排他锁 和 共享锁                      此两者作用不同，使用场景不同</li>
<li>在没有使用索引的情况下InnoDB就会使用表级锁(共享锁不会有这个情况）</li>
</ol>
<p>—————————————————————————————-施工中————————————————————————————–</p>
<p>在正式进入MVCC的讲述之前，需要先讲述‘快照读’和‘当前读’的概念</p>
<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p>MySQL中按照是否使用一致性非锁定读来分为快照读和当前读两个概念：</p>
<ul>
<li>快照读：读取记录数据的’可见版本’或者说’历史版本’，不加锁，普通的SELECT语句都是快照读</li>
<li>当前读：读取记录数据的’最新版本’，显式加锁（FOR UPDATE、LOCK IN SHARE MODE）的是当前读，此外，更新操作（INSERT、UPDATE、DELETE）也是当前读，会加锁</li>
</ul>
<p>在读已提交和可重复读两种事务隔离级别下，普通的SELECT操作使用“快照读”，不会对数据加锁，也不会被事务阻塞。</p>
<p>在读已提交和可重复读两种事务隔离级别下，使用“当前读”的操作包括：</p>
<ul>
<li>SELECT LOCK IN SHARE MODE (共享锁)</li>
<li>SELECT FOR UPDATE （排他锁）</li>
<li>DELETE（排他锁）</li>
<li>UPDATE （排他锁）</li>
<li>INSERT INTO（排他锁）</li>
<li>REPLACE INTO（排他锁）</li>
<li>串行化事务隔离级别 </li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​    MVCC 即Multi-Version Concurrency Control – 基于版本的控制协议</p>
<p>​    它是<strong>理想模型</strong>（和MVC一样的理想模型）它具体指的是“<strong>维持一个数据的多个版本，使得读写操作没有冲突</strong>”，通过读取历史数据而对当前数据进行写入使得读写无冲突（因为读写操作对象不一样了嘛） （这里的历史也只是一个事务执行前的那个时间点而已 就几秒钟不到）</p>
<p>​    一般在数据库管理系统中实现对数据库的并发访问，在编程语言中实现事务内存</p>
<p>​    MVCC在MySQL中的中实现是为了提高数据库并发性能，用更好的方式解决读-写冲突，即使有读-写冲突也能做到不加锁非阻塞读</p>
<blockquote>
<p>​    InnoDB中同一行数据发生读写的时候都会加上锁阻塞住（行锁），如果一张表又读又写 对20行数据同时操作就会有40把锁，对40行数据操作就会有80行锁，对80行数据操作就会有160把锁，这种方式对于不需要太过保证安全但是并发量极大的情况来说实在太过繁琐，所以有了MVCC</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>MVCC的实现思路是乐观锁的第二种实现方式</p>
<p>具体来说是为每个事务加上单向增长的时间戳，为每个修改保存一个版本，版本号和时间戳关联，读操作只读取该事务开始的那个时刻的数据库快照</p>
<h3 id="MVCC的好处"><a href="#MVCC的好处" class="headerlink" title="MVCC的好处"></a>MVCC的好处</h3><p>​    MVCC是一群大牛不满意只能用悲观锁来解决读写冲突而想出来的一种开销更小更轻的来解决读写冲突的一种解决方案或者说是一种思想</p>
<p>MVCC可以使得 </p>
<ol>
<li>在并行数据库操作的时候，可以做到在 读操作的时候不需要阻塞写操作，在写操作的时候不需要阻塞读操作，提高并行读写性能</li>
<li>还可以解决脏读、幻读、不可重复读的问题 但是不能解决更新丢失的问题</li>
</ol>
<p>我们可以使用MVCC和乐观锁悲观锁组合的方式解决问题：</p>
<ul>
<li>MVCC + 悲观锁<pre><code>MVCC解决读写冲突，悲观锁解决写写冲突
</code></pre>
</li>
<li>MVCC + 乐观锁<pre><code>MVCC解决读写冲突，乐观锁解决读写冲突
</code></pre>
</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突和写写冲突导致的问题</p>
<h3 id="当前读、快照读和MVCC的关系"><a href="#当前读、快照读和MVCC的关系" class="headerlink" title="当前读、快照读和MVCC的关系"></a>当前读、快照读和MVCC的关系</h3><p>​    MVCC是理想模型（和MVC一样的理想模型）它具体指的是“维持一个数据的多个版本，使得读写操作没有冲突”。这个概念需要具体功能去实现 ，在数据库中，这个具体实现就是快照读。</p>
<p>​    再细致一点的话，快照读也是一个抽象概念，MVCC具体是由3个隐藏字段、undo log和read view实现的。</p>
<h3 id="MVCC的具体实现："><a href="#MVCC的具体实现：" class="headerlink" title="MVCC的具体实现："></a>MVCC的具体实现：</h3><p>主要通过版本链、undo日志、 Read view来实现</p>
<h4 id="1-版本链"><a href="#1-版本链" class="headerlink" title="1.版本链"></a>1.版本链</h4><p>我们数据库中的每行数据，除了我们看到的每一行数据之外，还有三个隐藏字段</p>
<p><code>db_trx_id</code>、<code>db_roll_pointer</code>、<code>db_row_id</code></p>
<ul>
<li><p><strong>db_trx_id</strong>:</p>
<pre><code>    6byte，最近修改(修改/插入)事务ID：记录创建这条数据/最后一次修改该数据的事务ID。
</code></pre>
</li>
<li><p><strong>db_roll_pointer</strong>:</p>
<pre><code>    7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
</code></pre>
</li>
<li><p><strong>db_row_id</strong>:</p>
<pre><code>    6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。
</code></pre>
</li>
</ul>
<blockquote>
<p>实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了</p>
</blockquote>
<p><img src="https://s1.328888.xyz/2022/03/13/gYFAQ.png" alt="gYFAQ.png"></p>
<p>​    如上图，<code>db_row_id </code>是数据库默认为该行记录生成的唯一隐式主键，<code>db_trx_id</code>是当前操作该记录的事务ID，而<code>db_roll_pointer</code>是一个回滚指针，用于配合<code>undo日志</code>，指向上一个旧版本。</p>
<p>​    每次对数据库记录进行改动，都会记录一条<code>undo日志</code> ，每条undo日志也都有一个<code>roll_pointer</code> 属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gYVR3.png" alt="gYVR3.png"></p>
<p>​    对该记录每次更新后，都会将旧值放到一条<code>undo日志</code> 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code> 属性连接成一个链表，我们把这个链表称之为<strong>版本链</strong>，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，在根据<code>ReadView</code>判断版本可见性的时候会用到。</p>
<h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo log"></a>2.undo log</h4><p>​    <code>Undo log </code>主要用于<strong>记录</strong>数据<strong>被修改之前</strong>的日志，在表信息修改之前先会把<strong>数据拷贝</strong>到<code>undo log</code>里.<br>当事务进行回滚时可以通过<code>undo log</code>里的日志进行<strong>数据还原</strong>。</p>
<h5 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h5><ol>
<li><p>保证事务在回滚时的原子性和一致性， 事务回滚的时候用的<code>undo log</code>的数据进行的恢复</p>
</li>
<li><p>用于MVCC的快照的数据，通过读取<code>undo log</code>中的历史数据可以实现不同事务版本号都有自己独立的快照数据版本</p>
</li>
</ol>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ul>
<li><p>insert undo log</p>
<p>​    代表事务在insert新纪录下产生的undo log，只供事务回滚时使用，并且在事务提交后可以被立即丢弃</p>
</li>
<li><p>update undo log（主要）</p>
<p>​    事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；</p>
<p>​    所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
</li>
</ul>
<h4 id="3-Read-View"><a href="#3-Read-View" class="headerlink" title="3.Read View"></a>3.Read View</h4><p>​    事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照。</p>
<p>​    记录并维护系统当前活跃事务的ID(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。</p>
<p>​    <code>Read View</code>主要是用来做<strong>可见性判断</strong>的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code> 读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code> 里面的某个版本的数据。</p>
<blockquote>
<p>​    对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，设计InnoDB的大叔提出了一个ReadView的概念。</p>
</blockquote>
<h5 id="Read-View中的属性"><a href="#Read-View中的属性" class="headerlink" title="Read View中的属性"></a>Read View中的属性</h5><ul>
<li><p><strong>trx_ids</strong>：表示在生成ReadView时，当前系统中活跃的读写事务的事务版本号集合</p>
</li>
<li><p><strong>low_limit_id</strong>：表示生成当前read view 时，“当前系统最大事务版本号+1”，即下一个将被分配的事务ID</p>
</li>
<li><p><strong>up_limit_id</strong>：表示生成ReadView时，活跃事务列表trx_ids中最小的事务ID。如果trx_ids为空，则up_limit_id 为 low_limit_id</p>
</li>
<li><p><strong>creator_trx_id</strong>：表示生成该ReadView的事务的事务id</p>
</li>
</ul>
<blockquote>
<p>源码指路：<a target="_blank" rel="noopener" href="https://github.com/facebook/mysql-5.6/blob/42a5444d52f264682c7805bf8117dd884095c476/storage/innobase/include/read0read.h#L125">https://github.com/facebook/mysql-5.6/blob/42a5444d52f264682c7805bf8117dd884095c476/storage/innobase/include/read0read.h#L125</a></p>
</blockquote>
<blockquote>
<p>注意：</p>
<ul>
<li>trx_ids 集合值可能不是连续的，比如是[1, 2, 4]，这时3号事务已经提交</li>
<li>low_limit_id 指的是‘当前系统最大事务版本号’，比如说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids 就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</li>
<li>只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</li>
</ul>
</blockquote>
<h5 id="Read-View可见性判断条件"><a href="#Read-View可见性判断条件" class="headerlink" title="Read View可见性判断条件"></a>Read View可见性判断条件</h5><ul>
<li><p><code>db_trx_id </code>&lt; <code>up_limit_id</code> || <code>db_trx_id</code> == <code>creator_trx_id</code> （显示）</p>
<p>​    如果数据事务ID小于read view中的最小活跃事务ID，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。</p>
<p>​    或者数据的事务ID等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。</p>
</li>
<li><p><code>db_trx_id</code> &gt;= <code>low_limit_id</code> （不显示）</p>
<p>​    如果数据事务ID大于read view 中的当前系统的最大事务ID，则说明该数据是在当前read view 创建之后才产生的，所以数据不显示。如果小于则进入下一个判断</p>
</li>
<li><p><code>db_trx_id</code>是否在活跃事务（<code>trx_ids</code> ）中</p>
<ul>
<li><p>不存在：则说明read view产生的时候事务已经commit了，这种情况数据则可以显示。</p>
</li>
<li><p>已存在：则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的。</p>
</li>
</ul>
</li>
</ul>
<p>​    如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到上一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的第一个版本。如果第一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。 </p>
<blockquote>
<p>​    在MySQL中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code> 隔离级别的的一个非常大的区别就是它们生成<code>Read View</code> 的时机不同:</p>
<ul>
<li>RC隔离级别下，是每个快照读都会生成并获取最新的Read View；</li>
<li>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View，之后的查询就不会重复生成了，所以一个事务的查询结果每次都是一样的。</li>
</ul>
</blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/waves___/article/details/105295060">https://blog.csdn.net/waves___/article/details/105295060</a></p>
<h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><h3 id="常规操作-1"><a href="#常规操作-1" class="headerlink" title="常规操作"></a>常规操作</h3><h4 id="截断表-1"><a href="#截断表-1" class="headerlink" title="截断表"></a>截断表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名；</span><br></pre></td></tr></table></figure>



<h4 id="级联操作设置"><a href="#级联操作设置" class="headerlink" title="级联操作设置"></a>级联操作设置</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">级联操作</span><br><span class="line"><span class="comment">-- 1. 添加级联操作</span></span><br><span class="line">	语法：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称</span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称) </span><br><span class="line">		<span class="keyword">ON</span> UPDATE CASCADE </span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br><span class="line"><span class="comment">-- 2. 分类：</span></span><br><span class="line">	<span class="number">1.</span> 级联更新：<span class="keyword">ON</span> UPDATE CASCADE</span><br><span class="line">	<span class="number">2.</span> 级联删除：<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCAD</span><br></pre></td></tr></table></figure>



<h3 id="Mysql锁实践"><a href="#Mysql锁实践" class="headerlink" title="Mysql锁实践"></a>Mysql锁实践</h3><p>在进行实操前，请先明晰一下几件事：</p>
<ol>
<li>SQLyog中多个窗体（多个连接）彼此之间是互相独立的，相当于有多个用户在同时操作数据库</li>
<li>每个窗口间的一些属性是不一样的。比如说 <code>autocommit</code>, 如果使用<code>SHOW VARIABLES LIKE &#39;autocommit&#39;;</code> 只能看到本连接的自动提交事务情况。<code>SHOW GLOBAL VARIABLES LIKE &#39;autocommit&#39;;</code>可以看到全局的自动提交事务情况。</li>
<li>部分属性在重新开启SQLyog后会自动还原成默认值。比如说<code>隔离等级</code> 、<code>autocommit</code>。</li>
</ol>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#查看mysql现已提供的存储引擎</span><br><span class="line"><span class="keyword">show</span> engines;</span><br><span class="line"></span><br><span class="line"># 查看当前表的构建语句  engine参数后显示存储引擎</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> account_info;</span><br><span class="line"></span><br><span class="line"># 查看下autocommit的值</span><br><span class="line">    <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line">    或</span><br><span class="line">    <span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line">    或</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;   <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"> </span><br><span class="line"># 设置autocommit值</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span><span class="operator">|</span><span class="number">1</span><span class="operator">|</span><span class="keyword">ON</span><span class="operator">|</span>OFF;  <span class="operator">/</span><span class="operator">/</span>只能修改单个连接</span><br><span class="line"> </span><br><span class="line"># 设置事务隔离等级 <span class="comment">-- 可重复读</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;   <span class="operator">/</span><span class="operator">/</span>设置 可重复读</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;  <span class="operator">/</span><span class="operator">/</span>设置 读未提交</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;    <span class="operator">/</span><span class="operator">/</span>设置 读已提交</span><br><span class="line"> </span><br><span class="line"># 查看当前会话的隔离级别：</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;  或  <span class="keyword">SELECT</span> @<span class="variable">@session</span>.tx_isolation;</span><br><span class="line"></span><br><span class="line">#查看全局的隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.tx_isolation;</span><br><span class="line"></span><br><span class="line">提示：在MySQL <span class="number">8.0</span><span class="number">.3</span> 中，tx_isolation 变量被 transaction_isolation 变量替换了。在 MySQL <span class="number">8.0</span><span class="number">.3</span> 版本中查询事务隔离级别，只要把上述查询语句中的 tx_isolation 变量替换成 transaction_isolation 变量即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#当前运行的所有事务</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.InnoDB_trx;  </span><br><span class="line">	# 在执行<span class="keyword">begin</span>和一条<span class="keyword">sql</span>之后你才能在这里看到对应的事务</span><br><span class="line"> </span><br><span class="line">#当前正在等待的锁  注意 应该是正在等待而非现在出现</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.InnoDB_locks; 	</span><br><span class="line"> </span><br><span class="line">#锁等待的对应关系</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.InnoDB_lock_waits </span><br><span class="line"></span><br><span class="line">#查看锁的情况</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;InnoDB_row_lock_%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_current_waits <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_time          <span class="operator">|</span> <span class="number">479764</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_time_avg      <span class="operator">|</span> <span class="number">39980</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_time_max      <span class="operator">|</span> <span class="number">51021</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB_row_lock_waits         <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">解释如下：</span><br><span class="line">InnoDB_row_lock_current_waits : 当前等待锁的数量</span><br><span class="line">InnoDB_row_lock_time : 系统启动到现在，锁定的总时间长度</span><br><span class="line">InnoDB_row_lock_time_avg : 每次平均锁定的时间</span><br><span class="line">InnoDB_row_lock_time_max : 最长一次锁定时间</span><br><span class="line">InnoDB_row_lock_waits : 系统启动到现在总共锁定的次数  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询是否锁表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database <span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> test     <span class="operator">|</span> tx1   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------+--------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 查看先当前库的线程情况：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> processlist;</span><br><span class="line"> </span><br><span class="line"># kill 进程</span><br><span class="line">kill <span class="number">1825</span>;</span><br><span class="line"> </span><br><span class="line"># 查看表是什么时候更新的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema<span class="operator">=</span><span class="string">&#x27;test1&#x27;</span> <span class="keyword">AND</span> table_name<span class="operator">=</span><span class="string">&#x27;rpt_test&#x27;</span> ;</span><br><span class="line"> </span><br><span class="line">#整个数据库备份</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="comment">--databases wxss  &gt; C:\Users\Administrator\Desktop\sql\wxss_database.sql</span></span><br></pre></td></tr></table></figure>

<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h5><p>接下来会为读者演示在SQLyog中实现死锁</p>
<ol>
<li><p>执行<code>SHOW VARIABLES LIKE &#39;autocommit&#39;;</code>查看autocommit值是否是off。如果不是则执行<code>SET autocommit = OFF</code>  关闭MySQL自动提交事务</p>
</li>
<li><p>双开sqlyog窗口</p>
<table>
<thead>
<tr>
<th>session_1</th>
<th>session_2</th>
</tr>
</thead>
<tbody><tr>
<td>set autocommit = 0;  – 关闭自动事务提交</td>
<td>set autocommit = 0;  – 关闭自动事务提交</td>
</tr>
<tr>
<td>正常处理：<br />SELECT account_id, account_nickname FROM account_info WHERE account_id = 3</td>
<td>正常处理：<br />select actor_id,first_name,last_name  from actor where actor_id = 178;</td>
</tr>
<tr>
<td>给account_id = 3的记录加share mode的共享锁<br />select account_id, account_nickname from account_info where account_id = 3  lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>session_2 仍可以查询数据，也可以对该记录加share mode的共享锁<br />SELECT account_id, account_nickname FROM account_info WHERE account_id = 3  LOCK IN SHARE MODE;</td>
</tr>
<tr>
<td>UPDATE account_info SET account_nickname = “观星先生” WHERE account_id = 3;<br />等待  — 在SQLyog的表现是 一直处于查询状态 查询编辑器上边在转圈圈 <br />此时 SELECT * FROM information_schema.InnoDB_locks; 结果会出现X锁和S锁</td>
<td></td>
</tr>
<tr>
<td></td>
<td>此时 session_2 也对该记录进行更新操作，则会导致 死锁退出： <br />UPDATE account_info SET account_nickname = “观星先生” WHERE account_id = 3; <br />ERROR 1213 (40001): Deadlock found when trying  to get lock; try restarting transaction</td>
</tr>
</tbody></table>
<p>PS:  </p>
<p>需要读者明晰以下几点：</p>
<ol>
<li>在<code>READ UNCOMMITTED</code>下，本事务操作不会被自己的锁锁住。比方说 session_1 给 <code>account_id = 3</code>数据添加共享锁后执行<code>update account_info set account_nickname = &quot;观星先生&quot; where account_id = 3;</code> 可以正常执行，无需等待。</li>
<li>现在解释以上示例中死锁出现原因：<ul>
<li><img src="https://s1.328888.xyz/2022/03/13/gYauW.png" alt="gYauW.png"></li>
<li>session_1 和 session_2 分别给同一数据添加 共享锁 和 排他锁 —— <code>排他锁 session_1</code> 被<code>共享锁 session_2</code>阻塞；<code>排他锁 session_2</code>被<code>共享锁 session_1</code>阻塞  彼此阻塞无法执行</li>
<li>正常死锁会自动释放，InnoDB有一个内在的死锁检测工具，当死锁超过一定时间后，会回滚其中一个事务，InnoDB_lock_wait_timeout可配置死锁等待超时时间。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="autocommit值"><a href="#autocommit值" class="headerlink" title="autocommit值"></a>autocommit值</h5><p>在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：</p>
<p>SET autocommit = 0|1|ON|OFF;</p>
<p>对取值的说明：</p>
<ul>
<li>值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。</li>
<li>值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。</li>
</ul>
<h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 修改表引擎方法</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"># 关闭InnoDB引擎方法</span><br><span class="line">关闭mysql服务： net stop mysql</span><br><span class="line">找到mysql安装目录下的my.ini文件：</span><br><span class="line">找到<span class="keyword">default</span><span class="operator">-</span>storage<span class="operator">-</span>engine<span class="operator">=</span>InnoDB 改为<span class="keyword">default</span><span class="operator">-</span>storage<span class="operator">-</span>engine<span class="operator">=</span>MYISAM</span><br><span class="line">找到#<span class="keyword">skip</span><span class="operator">-</span>InnoDB 改为<span class="keyword">skip</span><span class="operator">-</span>InnoDB</span><br><span class="line">启动mysql服务：net <span class="keyword">start</span> mysql</span><br></pre></td></tr></table></figure>





<h3 id="InnoDB-Monitor-InnoDB监视器"><a href="#InnoDB-Monitor-InnoDB监视器" class="headerlink" title="InnoDB Monitor(InnoDB监视器)"></a>InnoDB Monitor(InnoDB监视器)</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/george_auyeung/article/details/83508317">InnoDB Monitor(InnoDB监视器)</a></p>
<h2 id="尾注"><a href="#尾注" class="headerlink" title="尾注"></a>尾注</h2><h3 id="尾注I-并发量"><a href="#尾注I-并发量" class="headerlink" title="尾注I:   并发量"></a>尾注I:   并发量</h3><h3 id="尾注II-Purge线程"><a href="#尾注II-Purge线程" class="headerlink" title="尾注II: Purge线程"></a>尾注II: Purge线程</h3><p>参考资料： <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/646471#:~:text=Purge%E7%BA%BF%E7%A8%8B%E5%8C%85,ysql%E4%B8%AD%E5%88%9B%E5%BB%BA%E3%80%82">MySQL Innodb Purge简介</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="2PL和S2PL区别"><a href="#2PL和S2PL区别" class="headerlink" title="2PL和S2PL区别"></a>2PL和S2PL区别</h3><p><strong>什么是2PL：</strong></p>
<p>​    <strong>2PL</strong>即‘<strong>两阶段加锁协议</strong>’</p>
<p>​    整个事务分为两个阶段，前一个阶段加锁，称为扩展阶段，后一个阶段解锁，称为收缩阶段。在扩展阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入收缩阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。</p>
<p>​    一句话解释即 ‘<strong>在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前。</strong>’</p>
<p>如下图所示:</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gYn3k.png" alt="gYn3k.png"></p>
<p><strong>为什么需要两阶段加锁</strong></p>
<p>引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。</p>
<p><strong>工程实践中的两阶段加锁-S2PL</strong></p>
<p>​    在实际情况下，SQL是千变万化、条数不定的,数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL(Strict-2PL)。</p>
<p>​    当一个事务获取到了某一个数据库对象的锁之后，并不是当前事务不需要操作它了之后，这个锁就会马上释放掉，这个锁会一直被这个事务持有，直到这个事务被提交或回滚后，这个锁才会被释放掉。所以，在当前事务还没有结束的时候，任何其他事务尝试获取这个锁的时候，都会被阻塞。知道当前事务提交或回滚后，前提事务才可以获取到这把锁。</p>
<p>一句话解释，即‘ <strong>在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段， 其余时间为加锁阶段。</strong>’</p>
<p>如下图所示:</p>
<p><img src="https://s1.328888.xyz/2022/03/13/gY1Ed.png" alt="gY1Ed.png"></p>
<p>这样的话，在实际的数据库中就很容易实现了。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xmtblog/article/details/104980789">完整的剖析 MySQL 两阶段加锁（2PL）协议</a></p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>即 <strong>二阶段提交协议（Two-phase Commit）</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bc8web/p/8116447.html">【MySQL】MySQL事务一致性理解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.php.cn/MySQL-tutorials-474519.html#:~:text=1">不可重复读和幻读的区别是什么-MySQL教程-PHP中文网</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jojop/p/13982679.html">【MySQL】MySQL中的锁机制 - 周二鸭 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengyangcai/p/14431983.html">理解MySQL的乐观锁，悲观锁与MVCC</a></p>
<p><a target="_blank" rel="noopener" href="https://www.php.cn/mysql-tutorials-460111.html">全网最全的一篇数据库MVCC详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xmtblog/article/details/104980789">完整的剖析 MySQL 两阶段加锁（2PL）协议</a></p>
<p> <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/646471#:~:text=Purge%E7%BA%BF%E7%A8%8B%E5%8C%85,ysql%E4%B8%AD%E5%88%9B%E5%BB%BA%E3%80%82">MySQL Innodb Purge简介</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:null">stella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leonardo-watch.github.io/2022/03/14/MySQL1.0/">https://leonardo-watch.github.io/2022/03/14/MySQL1.0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Leonardo-watch.github.io" target="_blank">stella's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-I/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端学习-I</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/26/Spring%E6%89%93war%E5%8C%85/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring项目打war包</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%B0%8F%E7%BE%8A%E5%95%8A.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">stella</div><div class="author-info__description">这里是stella的博客啦！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/public/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/public/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/public/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leonardo-watch"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Leonardo-watch" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sparkle8628@gmail.com" target="_blank" title="Email"><i class="fab fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">这是莱纳的个人博客哒！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E7%BB%BC%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">MySQL综合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E7%9F%A5%E6%82%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">读者知悉</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">理论：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">常规操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%93%8D%E4%BD%9C-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.3.4.</span> <span class="toc-text">sql操作(增删改查)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0-%E6%8F%92%E5%85%A5"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">增加(插入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.4.4.1.</span> <span class="toc-text">连接查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.4.4.2.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.4.4.3.</span> <span class="toc-text">多表查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.5.</span> <span class="toc-text">级联操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E8%A1%A8"><span class="toc-number">1.3.6.</span> <span class="toc-text">截断表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.7.</span> <span class="toc-text">常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">事务特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">持久性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">隔离性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.2.</span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">数据库并发场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB-%E8%AF%BB"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">读-读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB-%E5%86%99"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">读-写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99-%E5%86%99"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">写-写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">幻读</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B2%BE%E7%82%BC%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">1.4.4.3.1.</span> <span class="toc-text">精炼解释：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">更新丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.4.4.4.1.</span> <span class="toc-text">回滚丢失</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.4.4.4.2.</span> <span class="toc-text">覆盖丢失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7"><span class="toc-number">1.4.5.</span> <span class="toc-text">隔离等级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%88Read-uncommitted%EF%BC%89"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">读未提交（Read uncommitted）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%88Read-committed%EF%BC%89"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">读已提交（Read committed）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88Repeatable-read%EF%BC%89"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">可重复读（Repeatable read）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%88Serializable%EF%BC%89"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">可串行化（Serializable）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.6.</span> <span class="toc-text">隔离等级实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.5.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">锁类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%92%E5%BA%A6%E9%94%81"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">粒度锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.1.1.1.1.</span> <span class="toc-text">单行数据加锁原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.1.1.1.2.</span> <span class="toc-text">多行数据加锁原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%94%81"><span class="toc-number">1.5.1.1.3.</span> <span class="toc-text">页锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B2%92%E5%BA%A6%E9%94%81%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.1.1.4.</span> <span class="toc-text">不同粒度锁的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">锁模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%94%81"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">InnoDB中的行锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E8%A1%A8%E9%94%81%E2%80%94%E2%80%94%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">InnoDB表锁——意向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%BC%E5%AE%B9%E6%83%85%E5%86%B5"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">锁模式的兼容情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%8A%A0%E9%94%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">InnoDB加锁方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81-1"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#select-%E2%80%A6-for-update"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">select … for update</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select-%E2%80%A6-lock-in-share-mode"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">select … lock in share mode</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81-1"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">InnoDB的锁争用情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E8%A1%8C%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.4.</span> <span class="toc-text">InnoDB行锁的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Lock%EF%BC%89"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">记录锁（Record Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">间隙锁（Gap Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-key-Lock%EF%BC%89"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">临键锁（Next-key Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Lock%EF%BC%89"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">插入意向锁（Insert Intention Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E9%94%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9"><span class="toc-number">1.5.4.5.</span> <span class="toc-text">不同类型锁之间的兼容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E2%80%94-%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">1.5.5.</span> <span class="toc-text">MyISAM — 表级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.5.6.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E6%BE%84%E6%B8%85"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">乐观锁和悲观锁的澄清</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Concurrency-Control%EF%BC%89"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">悲观锁（Pessimistic Concurrency Control）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.6.2.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.6.2.2.</span> <span class="toc-text">优点与缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Concurrency-Control%EF%BC%89"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">乐观锁（Optimistic Concurrency Control）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.5.6.3.1.</span> <span class="toc-text">工作原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-CAS%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.6.3.1.1.</span> <span class="toc-text">1.CAS思想</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.6.3.1.2.</span> <span class="toc-text">2.具体实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.6.3.2.</span> <span class="toc-text">优点和缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E6%8A%89%E6%8B%A9"><span class="toc-number">1.5.6.3.3.</span> <span class="toc-text">乐观锁和悲观锁的抉择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.7.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.5.7.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.5.8.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.5.9.</span> <span class="toc-text">快照读和当前读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">1.6.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">MVCC的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8CMVCC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.4.</span> <span class="toc-text">当前读、快照读和MVCC的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.6.5.</span> <span class="toc-text">MVCC的具体实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">1.版本链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-undo-log"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">2.undo log</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A"><span class="toc-number">1.6.5.2.1.</span> <span class="toc-text">用途：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.6.5.2.2.</span> <span class="toc-text">分类：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Read-View"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">3.Read View</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Read-View%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.5.3.1.</span> <span class="toc-text">Read View中的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Read-View%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.6.5.3.2.</span> <span class="toc-text">Read View可见性判断条件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">实践：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">常规操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E8%A1%A8-1"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">截断表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">级联操作设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E9%94%81%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.7.2.</span> <span class="toc-text">Mysql锁实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.7.2.2.1.</span> <span class="toc-text">入门</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#autocommit%E5%80%BC"><span class="toc-number">1.7.2.3.1.</span> <span class="toc-text">autocommit值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">其他指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-Monitor-InnoDB%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">InnoDB Monitor(InnoDB监视器)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E6%B3%A8"><span class="toc-number">1.8.</span> <span class="toc-text">尾注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E6%B3%A8I-%E5%B9%B6%E5%8F%91%E9%87%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">尾注I:   并发量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E6%B3%A8II-Purge%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">尾注II: Purge线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">1.9.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2PL%E5%92%8CS2PL%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.1.</span> <span class="toc-text">2PL和S2PL区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2PC"><span class="toc-number">1.9.2.</span> <span class="toc-text">2PC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.9.3.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/27/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="Git基本使用"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git基本使用"/></a><div class="content"><a class="title" href="/2022/06/27/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="Git基本使用">Git基本使用</a><time datetime="2022-06-27T14:04:50.000Z" title="发表于 2022-06-27 22:04:50">2022-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E6%8A%A5%E9%94%99/" title="前端问题 -- ESLint规范导致前端build失败"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端问题 -- ESLint规范导致前端build失败"/></a><div class="content"><a class="title" href="/2022/06/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E6%8A%A5%E9%94%99/" title="前端问题 -- ESLint规范导致前端build失败">前端问题 -- ESLint规范导致前端build失败</a><time datetime="2022-06-27T02:50:55.000Z" title="发表于 2022-06-27 10:50:55">2022-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/25/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" title="后台服务器优化指南（优化记录）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="后台服务器优化指南（优化记录）"/></a><div class="content"><a class="title" href="/2022/06/25/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" title="后台服务器优化指南（优化记录）">后台服务器优化指南（优化记录）</a><time datetime="2022-06-25T02:07:44.000Z" title="发表于 2022-06-25 10:07:44">2022-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/%E5%8F%B2%E4%B8%8A%E6%97%A0%E6%95%8C%E8%AF%A6%E7%BB%86%E7%9A%84OpenVPN%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" title="史上无敌详细的OpenVPN搭建教程"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="史上无敌详细的OpenVPN搭建教程"/></a><div class="content"><a class="title" href="/2022/06/19/%E5%8F%B2%E4%B8%8A%E6%97%A0%E6%95%8C%E8%AF%A6%E7%BB%86%E7%9A%84OpenVPN%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" title="史上无敌详细的OpenVPN搭建教程">史上无敌详细的OpenVPN搭建教程</a><time datetime="2022-06-19T05:35:58.000Z" title="发表于 2022-06-19 13:35:58">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/18/CentOS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="CentOS遇到的问题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CentOS遇到的问题"/></a><div class="content"><a class="title" href="/2022/06/18/CentOS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="CentOS遇到的问题">CentOS遇到的问题</a><time datetime="2022-06-18T15:44:35.000Z" title="发表于 2022-06-18 23:44:35">2022-06-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By stella</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/hexo-helper-live2d/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"hexo-helper-live2d/","pluginJsPath":"lib/","pluginModelPath":"node_modules/live2d-widget-model-miku/assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/hexo-helper-live2d/node_modules/live2d-widget-model-miku/assets/live2d-widget-model-koharu/assets/koharu.model.json"},"display":{"position":"left"},"mobile":{"show":false},"dialog":{"enable":true},"log":false});</script></body></html>